<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>chronixd-location Viewer</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #controls {
      padding: 12px;
      background: #f5f5f5;
      border-bottom: 1px solid #ddd;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    #controls input, #controls button {
      padding: 8px 12px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }
    #controls input[type="password"] {
      width: 200px;
    }
    #controls button {
      background: #0066cc;
      color: white;
      border: none;
      cursor: pointer;
    }
    #controls button:hover {
      background: #0055aa;
    }
    #controls button:disabled {
      background: #999;
      cursor: not-allowed;
    }
    #status {
      font-size: 12px;
      color: #666;
    }
    #status.error {
      color: #cc0000;
    }
    #map {
      flex: 1;
    }
  </style>
</head>
<body>
  <div id="controls">
    <input type="password" id="token" placeholder="API Token">
    <input type="date" id="date">
    <button id="loadBtn" onclick="loadLocations()">Load</button>
    <span id="status"></span>
  </div>
  <div id="map"></div>

  <script>
    const STORAGE_KEY = 'chronixd-location-token';
    let map;
    let currentLayer = null;
    let currentPolyline = null;

    // 時刻に基づいて色を計算（朝=暖色系、昼=青系、夕=オレンジ系、夜=紫系）
    function getColorByTime(timestamp) {
      const date = new Date(timestamp);
      const hour = date.getHours() + date.getMinutes() / 60;

      // 時刻による色相と明度のマッピング
      // 0-6時: 夜（暗い紫→朝焼けオレンジへ）
      // 6-12時: 朝→昼（オレンジ→明るい青へ）
      // 12-18時: 昼→夕（青→夕焼けオレンジへ）
      // 18-24時: 夕→夜（オレンジ→暗い紫へ）

      let hue, saturation, lightness;

      if (hour < 6) {
        // 深夜→早朝: 暗い紫(270)→オレンジ(30)
        const t = hour / 6;
        hue = 270 - t * 240; // 270→30 (時計回りで短い方)
        if (hue < 0) hue += 360;
        saturation = 60 + t * 20;
        lightness = 30 + t * 25; // 暗い→明るめ
      } else if (hour < 12) {
        // 朝→昼: オレンジ(30)→青(200)
        const t = (hour - 6) / 6;
        hue = 30 + t * 170;
        saturation = 80 - t * 10;
        lightness = 55 - t * 5; // やや明るめをキープ
      } else if (hour < 18) {
        // 昼→夕: 青(200)→オレンジ(30)
        const t = (hour - 12) / 6;
        hue = 200 - t * 170;
        saturation = 70 + t * 15;
        lightness = 50 + t * 5;
      } else {
        // 夕→夜: オレンジ(30)→暗い紫(270)
        const t = (hour - 18) / 6;
        hue = 30 + t * 240;
        saturation = 85 - t * 25;
        lightness = 55 - t * 25; // 明るめ→暗い
      }

      return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function init() {
      // Initialize map centered on Tokyo
      map = L.map('map').setView([35.6762, 139.6503], 10);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      // Get parameters from hash (#token=xxx&date=xxx) or query string (?token=xxx)
      // Hash is preferred as it's not sent to server
      const hashParams = new URLSearchParams(window.location.hash.slice(1));
      const queryParams = new URLSearchParams(window.location.search);

      const urlToken = hashParams.get('token') || queryParams.get('token');
      const urlDate = hashParams.get('date') || queryParams.get('date');

      // Token priority: URL param > localStorage
      const token = urlToken || localStorage.getItem(STORAGE_KEY);
      if (token) {
        document.getElementById('token').value = token;
        if (urlToken) {
          localStorage.setItem(STORAGE_KEY, urlToken);
        }
      }

      // Date priority: URL param > today (local timezone)
      const today = Temporal.Now.plainDateISO().toString();
      document.getElementById('date').value = urlDate || today;

      // Auto-load if token and date are set via URL
      if (urlToken && urlDate) {
        loadLocations();
      }
    }

    function setStatus(message, isError = false) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = isError ? 'error' : '';
    }

    async function loadLocations() {
      const tokenInput = document.getElementById('token');
      const dateInput = document.getElementById('date');
      const loadBtn = document.getElementById('loadBtn');

      const token = tokenInput.value.trim();
      const date = dateInput.value;

      if (!token) {
        setStatus('API Tokenを入力してください', true);
        tokenInput.focus();
        return;
      }

      if (!date) {
        setStatus('日付を選択してください', true);
        dateInput.focus();
        return;
      }

      // Save token
      localStorage.setItem(STORAGE_KEY, token);

      loadBtn.disabled = true;
      setStatus('Loading...');

      try {
        // Convert local date to from/to using Temporal API
        const fromPlainDate = Temporal.PlainDate.from(date);
        const toPlainDate = fromPlainDate.add({ days: 1 });
        const timeZone = Temporal.Now.timeZoneId();
        const midnight = Temporal.PlainTime.from('00:00:00');
        const from = fromPlainDate.toZonedDateTime({ timeZone, plainTime: midnight }).toInstant().toString();
        const to = toPlainDate.toZonedDateTime({ timeZone, plainTime: midnight }).toInstant().toString();
        const response = await fetch(`/api/locations?from=${from}&to=${to}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (!response.ok) {
          if (response.status === 401) {
            setStatus('認証エラー: トークンを確認してください', true);
            localStorage.removeItem(STORAGE_KEY);
            tokenInput.value = '';
            tokenInput.focus();
            return;
          }
          throw new Error(`HTTP ${response.status}`);
        }

        const geojson = await response.json();

        // Remove previous layers
        if (currentLayer) {
          map.removeLayer(currentLayer);
        }
        if (currentPolyline) {
          map.removeLayer(currentPolyline);
        }

        if (geojson.features.length === 0) {
          setStatus(`${date} のデータはありません`);
          return;
        }

        // Sort features by timestamp
        const sortedFeatures = [...geojson.features].sort((a, b) => {
          return new Date(a.properties.timestamp) - new Date(b.properties.timestamp);
        });
        const totalPoints = sortedFeatures.length;

        // Create polyline coordinates for the path
        const polylineCoords = sortedFeatures.map(f => [
          f.geometry.coordinates[1], // lat
          f.geometry.coordinates[0]  // lng
        ]);

        // Add polyline (movement path)
        currentPolyline = L.polyline(polylineCoords, {
          color: '#0066cc',
          weight: 2,
          opacity: 0.5,
          dashArray: '5, 5'
        }).addTo(map);

        // Create a map to store index for each feature
        const featureIndexMap = new Map();
        sortedFeatures.forEach((f, index) => {
          const key = `${f.geometry.coordinates[0]},${f.geometry.coordinates[1]},${f.properties.timestamp}`;
          featureIndexMap.set(key, index);
        });

        // Add GeoJSON layer with gradient colors
        currentLayer = L.geoJSON({ ...geojson, features: sortedFeatures }, {
          pointToLayer: (feature, latlng) => {
            const color = getColorByTime(feature.properties.timestamp);
            const hasPoi = feature.properties.poi || feature.properties.address;

            return L.circleMarker(latlng, {
              radius: hasPoi ? 10 : 6,
              fillColor: color,
              color: hasPoi ? '#ffffff' : color,
              weight: hasPoi ? 3 : 2,
              opacity: 1,
              fillOpacity: hasPoi ? 1 : 0.8
            });
          },
          onEachFeature: (feature, layer) => {
            const props = feature.properties;
            const key = `${feature.geometry.coordinates[0]},${feature.geometry.coordinates[1]},${props.timestamp}`;
            const index = featureIndexMap.get(key) || 0;
            const time = new Date(props.timestamp).toLocaleTimeString('ja-JP');
            const coords = feature.geometry.coordinates;

            let popup = `<b>#${index + 1} ${time}</b><br>`;

            if (props.poi) {
              popup += `<b>${props.poi}</b><br>`;
            }
            if (props.address) {
              popup += `${props.address}<br>`;
            }

            popup += `座標: ${coords[1].toFixed(5)}, ${coords[0].toFixed(5)}<br>`;

            if (props.speed !== undefined && props.speed >= 0) {
              popup += `速度: ${(props.speed * 3.6).toFixed(1)} km/h<br>`;
            }
            if (props.altitude !== undefined) {
              popup += `高度: ${props.altitude.toFixed(0)} m<br>`;
            }
            if (props.battery_level !== undefined) {
              popup += `バッテリー: ${(props.battery_level * 100).toFixed(0)}%<br>`;
            }
            if (props.horizontal_accuracy !== undefined) {
              popup += `精度: ${props.horizontal_accuracy.toFixed(0)} m`;
            }

            layer.bindPopup(popup);

            const tooltipText = props.poi
              ? `#${index + 1} ${time} - ${props.poi}`
              : `#${index + 1} ${time}`;
            layer.bindTooltip(tooltipText, {
              direction: 'top',
              offset: [0, -8]
            });
          }
        }).addTo(map);

        // Fit bounds to show all points
        map.fitBounds(currentLayer.getBounds(), { padding: [50, 50] });

        setStatus(`${geojson.features.length} 件のデータを表示`);
      } catch (error) {
        console.error('Load error:', error);
        setStatus(`エラー: ${error.message}`, true);
      } finally {
        loadBtn.disabled = false;
      }
    }

    // Initialize on load
    init();
  </script>
</body>
</html>
